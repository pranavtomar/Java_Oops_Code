package DemoPackage;
import java.lang.String;

public class HelloWorld {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		System.out.println("my name is Pranav");
//		System.out.println("Door no. 222");
//		System.out.println("Rahimabad, Malihabad, Lucknow");
//		String str = "abc";
//		System.out.println(str);
//		int phno = 45382;
//		12 = int numOne;
//		double d = 3.1416285634857834589348;
//		System.out.println(d);
//		str = "";
//		long l = 999999999999999999l;
//		int value = (int)l;
//		System.out.println(value);
//		System.out.println(l);
		
//		int numOne = 6%(-4);
//		int numTwo = (-6)%(-4);
//		int numThree = (-6)%4;
//		System.out.println(numOne+" "+numTwo+" "+numThree);
		
//		char ch1 = 'a';
//		char ch2 = 'b';
//		double d3 = ch1 > ch2 ? 0.5 : 0.6;
//		System.out.println(d3);
		
//		int numOne = 12;
//		int numTwo = 12;
//		System.out.println(numOne.equals(numTwo));
		
//		int a;
//		switch(a=97) {
//		case 'a':
//			System.out.println("a");
//		case 22:
//			System.out.println("b");
//		default:
//			System.out.println("not a and b");
//		}
		
		
//				// Shift operator (<< and >>) is used to move the left operands value by
//				// the number of bits specified.
//				int a = 10;
//				int b = 20;
//
//				// Bitwise operators are used to perform manipulation of individual bits
//
//				// Logical OR(||) does not check second condition if first is true
//				// Bitwise OR(|) always checks both conditions even if first condition
//				// is true or false
//				System.out.println(a | b);
//
//				// Logical AND(&&) does not check second condition if first is false
//				// Bitwise AND(&) checks both conditions even if first condition is true
//				// or false
//				System.out.println(a & b);
		
//		float principal = 5000, rate = 10, time =5;
//		float simpleInterest = (principal*rate*time)/100.0f;
//		float principal2 = 3250, rate2 = 7, time2 =3;
//		float simpleInterest2 = (principal2*rate2*time2)/100.0f;
//		System.out.println(simpleInterest);
//		System.out.println(simpleInterest2);
		
//		int x = 65;
//		char y = (char)x;
//		System.out.println(y);
		
//		int variableOne = 10;
//		float variableTwo = variableOne;
//		System.out.println(variableOne);
//		System.out.println(variableTwo);
		// Here, a variable of data type having smaller range is automatically
		// accommodated in a variable of data type having bigger range. This is
		// known as widening.

		// When we try to accommodate a variable of data type having bigger
		// range into a data type having smaller range, it leads to an error.
//		float variableThree = 12.5f;
	//	int variableFour = variableThree; // comment this line or fix the error
											// to execute the code successfully
//		System.out.println(variableThree);
	//	System.out.println(variableFour); // comment this line or fix the error
											// to execute the code successfully

		// Since our assignment is leading to loss of data, we need to
		// explicitly specify that the data needs to be converted to a data type
		// having smaller range.
		// This is known as explicit typecasting.
//		int variableFive = (int) variableThree;
//		System.out.println(variableFive);
		
//		int num1 = 3, num2 = 4, num3 = 1;
//		if(num1>num3){
//		      System.out.println(num1);
//		   }else{
//		      System.out.println(num3);
//		   }
		
		
//		int i = (2, 3, 4, 5);
		
		int a = 5;
		int b = 4;
		int c = a^b;
		System.out.println(c);
		
		
	}

}
